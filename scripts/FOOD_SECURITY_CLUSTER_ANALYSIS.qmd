---
title: "CLUSTER ANALYSIS"
format: html
editor: visual
---

```{r load-packages}

source(here::here('scripts', 'library.R'))
```

# Indicator selection

```{r cluster_data}
# load all variables that could be used as food security indicators
load(here('data', 'production.RData'))
load(here('data', 'consumption.RData'))
load(here('data', 'transversal.RData'))

# create a dataframe w/ all indicators
cluster_data <- merge(consumption %>% st_drop_geometry(), 
                      production %>% st_drop_geometry(),
                      by = 'grappe') %>% 
  merge(transversal %>% st_drop_geometry(),
                      by = 'grappe') %>% 
  column_to_rownames(var = "grappe")

vis_miss(cluster_data)

```

```{r corr_matrix}
# normalize data
cluster_scaled <- scale(cluster_data) |> 
  as.data.frame()

# correlation matrix
corr_matrix <- cor(cluster_scaled)
score_matrix <- score_matrix(cluster_scaled) # check non-linear relationships

# viz
heatmap(score_matrix, scale = "none")

col <- colorRampPalette(brewer.pal(10, "RdYlBu"))(256)
heatmap(corr_matrix, scale = "none", col =  rev(col))

```

```{r indicator_balancing}
# reduce number of variables to avoid collinearity
cluster_balanced <- cluster_data %>% 
    select(-c(diet_diversified, food_prices_avg, sh_fatalities))

cluster_norm_balanced <- cluster_scaled %>% 
    select(-c(diet_diversified, food_prices_avg,sh_fatalities))

# correlation matrix
corr_matrix_balanced <- cor(scale(cluster_norm_balanced))
score_matrix_balanced <- score_matrix(cluster_norm_balanced)

```

```{r png_matrix}

png(file=here('outputs', 'heatmap_corr.png'),
width=1000, height=800)
col <- colorRampPalette(brewer.pal(10, "RdYlBu"))(256)
heatmap(corr_matrix_balanced, scale = "none", col =  rev(col))
dev.off()

png(file=here('outputs', 'heatmap_pps.png'),
width=1000, height=800)
heatmap(score_matrix_balanced, scale = "none", col =  rev(col))
dev.off()
```

# Principal Component Analysis (PCA)

```{r}

result<-PCAtest(cluster_balanced, 100, 100, 0.05, indload=TRUE, varcorr=FALSE, counter=FALSE, plot=TRUE)
# The first 2 PC axes are significant and account for 49.6% of the total variation

data_pca <- PCA(cluster_norm_balanced, graph = FALSE)
summary(data_pca)
data_scores <- data_pca$ind$coord[,1:3]

# Kaizer criterion: keep eigenvalue PC > 1
# data_pca$eig[,1]^2

save(cluster_balanced, cluster_norm_balanced, corr_matrix_balanced, score_matrix_balanced, data_pca, data_scores, file = here('data', 'pca_results.RData'))
```

# Hierarchical clustering

```{r}

# distance matrix
data_dist <- dist(data_scores, method = "euclidian") 
# hierarchical clustering w/ Ward's method
data_tree <- hclust(data_dist, method = "ward.D2")

# compute correlation between the cophenetic distances and the distance matrix (i.e. here factor scores) to measure how well the cluster tree reflects the data
# high correlation means high accuracy of the clustering solution
tree_coph <- cophenetic(data_tree)
cor(data_dist, tree_coph)

# Number of clusters
# load required packages
library(factoextra)
library(NbClust)

res_ward.D2 <- NbClust(data_scores, distance = "euclidean", min.nc=2, max.nc=6,
        method = "ward.D2", index = "all")
res_ward.D <- NbClust(data_scores, distance = "euclidean", min.nc=2, max.nc=6,
        method = "ward.D", index = "all")
res_kmeans <- NbClust(data_scores, distance = "euclidean", min.nc=2, max.nc=6,
        method = "kmeans", index = "all")

# cut tree in three clusters
cluster <- cutree(data_tree, k = 3)
cluster_tree <- data.frame(cluster, cluster_norm_balanced)

# cluster_tree <- cluster_tree %>% mutate(cluster = if_else(cluster == 4, 3, cluster))

save(data_dist, data_tree, cluster_tree, file = here('data', 'hca_results.RData'))
```

```{r contributation_indicators}

# estimate the overall mean value of each indicator
# assign each indicator to a food security dimension
mean_total <- bind_rows(map(cluster_norm_balanced, mean)) |> 
  pivot_longer(everything()) |> 
  mutate(
    dimension = fct_relevel(as_factor(
        case_when(
      name %in% c('biodiversity_intactness_index', 'water_depletion_ratio', 'sh_total_precipitation', 'sh_built_up_change') ~ 'Potential',
      name %in% c('sh_landless', 'sh_input_from_market', 'empl_food_processing', 'sh_credit_access') ~ 'Availability',
      name %in% c('sh_imp_rice', 'food_prices_med', 'sh_livestock', 'income') ~ 'Access',
      name %in% c('fridge', 'education', 'sh_health_facility', 'diet_nutritive') ~ 'Utilization',
      name %in% c('sh_transport_cost', 'sh_market_access', 'sh_freq_vio_events', 'sh_mobile_phone') ~ 'Transversal')),
  "Potential", "Availability", "Access", "Utilization", "Transversal"),
  category = case_when(
    dimension %in% c("Potential", "Availability") ~ "Production",
    dimension %in% c("Access", "Utilization") ~ "Consumption",
    .default = "Transversal"
  ))
  
# estimate the mean value of each indicator at the cluster level
mean_cluster <- cluster_tree |> 
  rename(cluster = cluster) %>% 
  group_by(cluster) |> 
  summarize(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>% 
  mutate(cluster = as.factor(cluster))

mean_cluster_list <- split(mean_cluster, 1:nrow(mean_cluster))
mean_cluster_list <- lapply(mean_cluster_list, function(df) pivot_longer(df, !cluster))
       
mean_cluster_list <- lapply(mean_cluster_list, function(df) merge(df, mean_total, by = "name", suffixes = c(".cluster",".total")))

# estimate difference between overall and cluster means
mean_cluster_list <- lapply(mean_cluster_list, function(df) mutate(df, diff = value.cluster - value.total))

mean_cluster <- rbindlist(mean_cluster_list) %>% 
    mutate(name = reorder_within(name, diff, cluster))

save(mean_total, mean_cluster_list, mean_cluster, file = here('data', 'value_indicators.RData'))
```

```{r viz_hclust}

hclust_palette <- c('#FC564F', '#FFC000', '#00B050')

# Clusters = 3
png(file=here('outputs', 'hclust_3.png'),
width=700, height=500)
# graph visualization
require("igraph")
fviz_dend(data_tree, k = 3,
     cex = .5, # label size
     rect = TRUE,
     k_colors = hclust_palette
)
dev.off()
```

```{r viz_profiles}

palette_dim <- c('#005DB9', '#C4EAFF', '#7030A0', '#EFE5F7')
palette_cat <- c('#005DB9', '#7030A0')

ggplot(mean_cluster) +
    geom_bar(aes(x =name, y = diff, fill = category),
             stat = "identity") +
    coord_flip() +
    scale_fill_manual(values = c('#005DB9', '#7030A0', '#777378')) +
    labs(x = "Factor", y = "Deviation from average profile") +
    scale_x_reordered() +
    theme_minimal() +
    facet_wrap(~cluster, scales = "free")
    
# deviation from average for all variables for each cluster
lapply(mean_cluster_list, function(df) 
  df %>% 
    mutate(name = case_when(
      name == 'sh_total_precipitation' ~ 'Precipitation',
      name == 'sh_built_up_change' ~ 'Land use - Built-up change',
      name == 'water_depletion_ratio' ~ 'Water depletion',
      name == 'biodiversity_intactness_index' ~ 'Ecosystem services less',
      name == 'sh_landless' ~ 'Land rights - Landless households',
      name == 'sh_input_from_market' ~ 'Input market access',
      name == 'empl_food_processing' ~ 'Agri-food supply chain - Processing jobs',
      name == 'sh_credit_access' ~ 'Access to credit',
      name == 'sh_imp_rice' ~  'Trade - Imported rice',
      name == 'food_prices_med' ~  'Local food prices',
      name == 'sh_livestock' ~ 'Assets - Livestock',
      name == 'income' ~ 'Income - Relative poverty',
      name == 'fridge' ~ 'Food safety - Fridge ownership',
      name == 'education' ~ 'Intra-HH allocation - Women education',
      name == 'sh_health_facility' ~ 'Access to Basic services - Health',
      name == 'diet_nutritive' ~ 'Cooking habits - Lack of a nutritive diet',
      name == 'sh_transport_cost' ~ 'Transport costs',
      name == 'sh_market_access' ~ 'Market access',
      name == 'sh_freq_vio_events' ~ 'Violent events',
      name == 'sh_mobile_phone' ~ 'ICT - Mobile phone access'
    )) %>% 
  ggplot() +
    geom_bar(aes(x = reorder(name, diff), y = diff, fill = category), 
             stat = "identity") +
    coord_flip() +
    scale_fill_manual(values = c('#005DB9', '#7030A0', '#777378')) +
    labs(x = "Enabling/Constraining factors", y = '', fill = 'Food Security dimension') +
    theme_minimal()
)
```

```{r spatial_cluster}
load(here('data', 'hca_results.RData'))
load(here('data', 'grappes.RData'))

merge_cluster_to_grappe <- cluster_tree |> 
  rownames_to_column(var = "grappe") |> 
  select(grappe, cluster) |> 
  mutate(`Food security profile` = case_when(
    cluster == 1 ~ 'Cluster 1',
    cluster == 2 ~ 'Cluster 2',
    cluster == 3 ~ 'Cluster 3'
  ))

grappe_cluster_sf <- merge_cluster_to_grappe |> 
  merge(grappe_sf, by = "grappe") |> 
  st_as_sf()

st_write(grappe_cluster_sf, here('layers', 'grappe_cluster.gpkg'), delete_layer = TRUE)
save(merge_cluster_to_grappe, grappe_cluster_sf, file = here('data','cluster_data.RData'))
```

```{r population_proportion}

load(here('data','short_survey.RData'))

survey_cluster <- merge_cluster_to_grappe %>%
  mutate(grappe = as.numeric(grappe)) %>% 
  left_join(survey_welfare %>% 
              select(hhid, grappe, region, zae, hhweight, id_adm2), 
              by = "grappe")

survey_design <- survey_cluster %>% 
  as_survey_design(ids = c(grappe,hhid), 
                   strata = c(region, zae), 
                   weights = hhweight,
                   nest = TRUE)

# Estimate proportion of population in each cluster 
survey_design %>% 
  group_by(cluster) %>% 
  summarise(pct = 100*survey_prop(), vartype = "ci") %>% 
  select(-vartype) %>% 
  pivot_wider(names_from = cluster, values_from = c(pct, pct_se), values_fill = 0) %>% 
  select(-c(starts_with("pct_se")))


# Estimate proportions of each cluster in ADM2
cluster_idm2 <- survey_design %>% 
  group_by(id_adm2, cluster) %>% 
  summarise(pct = 100*survey_prop(), vartype = "ci") %>% 
  select(-vartype) %>% 
  pivot_wider(names_from = cluster, values_from = c(pct, pct_se), values_fill = 0) %>% 
  select(-c(starts_with("pct_se")))

```
